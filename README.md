jetty-maven-plugin会创建一个WebAppClassLoader，用来加载WebApp的相关jar包。这个WebAppClassLoader没有遵循双亲委托机制，而是遵循WebApp Servlet类加载规范，除非被定义为System或者Server的Class，否则都优先由自己加载。这么做的主要原因是可以隔离同一个Server下运行的多个WebApp的类包

Jetty中`DefaultServlet`默认被认为是System Class。假设自己写的一个`MyServlet`继承了`DefaultServlet`，并且import了`HttpContent`类。在启动Jetty Server的时候，会由`PluginClassRealm`类加载器加载`DefaultServlet(id: DefaultServlet-Plugin)`，同时也会将`HttpContent(id: HttpContent-Plugin)`加载进来。然后在启动WebApp的时候，会由`WebAppClassLoader`负责加载`MyServlet`，同时也要将其依赖`DefaultServlet`和`HttpContent`加载进来。由于`DefaultServlet`是System Class，所以`WebAppClassLoader`会委托其parent即`PluginClassRealm`去加载，由于之前启动Server的时候已经加载过，所以会返回之前加载好的`DefaultServlet(id: DefaultServlet-Plugin)`，其中引用的是`HttpContent-Plugin`。接下来由于`MyServlet`也引用了`HttContent`，所以会自己去加载`HttpContent(id: HttContent-WebApp)`。`MyServlet`如果覆盖了父类`DefaultServlet`的某个方法doSth，并且这个doSth方法的参数包含了`HttpContent`类型，那么就会引发类冲突。因为在父类`DefaultServlet`中，doSth的参数类型是`HttpContent-Plugin`，而子类`MyServlet`中，doSth参数类型为`HttpContent-WebApp`，看似类名字一样，实际类id是不同的，jvm会认为是不同的类但是名字相同，并且尝试覆盖产生混淆，所以抛出`java.lang.LinkageError: loader constraint violation`异常。如果`MyServlet`只是使用自己的`HttpContent-WebApp`是没有问题的。总而言之，不能将`HttpContent-WebApp`传给父类当做`HttpContent-Plugin`使用，即使他们的包名、类名、代码完全一样(jvm中不同的classloader加载相同的类其id是不同的)。
